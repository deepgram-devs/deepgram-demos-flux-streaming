<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deepgram FLUX API Demo</title>
    <style>
/* Deepgram Minimal Design System - FLUX Demo */
:root {
    --dg-primary: #13ef93;
    --dg-primary-light: #a1f9d4;
    --dg-primary-dark: #075433;
    --dg-primary-hover: #075433;
    --dg-secondary: #149afb;
    --dg-secondary-hover: #1184d4;
    --dg-success: #12b76a;
    --dg-warning: #fec84b;
    --dg-danger: #f04438;
    --dg-danger-hover: #e53e3e;
    --dg-white: #ffffff;
    --dg-fog-gray: #ededf2;
    --dg-platinum: #e1e1e5;
    --dg-french-gray: #bbbbbf;
    --dg-slate: #949498;
    --dg-quartz: #6b6b6f;
    --dg-gunmetal: #4e4e52;
    --dg-charcoal: #2b2b2f;
    --dg-eerie-black: #18181b;
    --dg-void: #0b0b0c;
    --dg-surface: var(--dg-charcoal);
    --dg-surface-elevated: var(--dg-gunmetal);
    --dg-border: var(--dg-quartz);
    --dg-border-strong: var(--dg-slate);
    --dg-text-primary: var(--dg-white);
    --dg-text-secondary: var(--dg-french-gray);
    --dg-text-muted: var(--dg-slate);
    --dg-text-inverse: var(--dg-void);
    --dg-text-disabled: var(--dg-quartz);
    --dg-font-family-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --dg-text-base: 0.875rem;
    --dg-text-sm: 0.75rem;
    --dg-text-lg: 1rem;
    --dg-text-xl: 1.25rem;
    --dg-font-weight-medium: 500;
    --dg-font-weight-semibold: 600;
    --dg-space-2: 0.5rem;
    --dg-space-3: 0.75rem;
    --dg-space-4: 1rem;
    --dg-space-5: 1.25rem;
    --dg-space-6: 1.5rem;
    --dg-space-8: 2rem;
    --dg-radius-sm: 0.125rem;
    --dg-radius-md: 0.375rem;
    --dg-radius-lg: 0.5rem;
    --dg-border-width-thin: 1px;
    --dg-shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    --dg-shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --dg-transition-fast: 150ms;
    --dg-transition-normal: 200ms;
}

body {
    font-family: var(--dg-font-family-body);
    background-color: var(--dg-void);
    color: var(--dg-text-primary);
    margin: 0;
    padding: var(--dg-space-5);
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--dg-space-5);
}

.dg-body-with-sticky-nav {
    padding-top: 80px;
}

@media (max-width: 768px) {
    .dg-body-with-sticky-nav {
        padding-top: 70px;
    }
}

.dg-container {
    background-color: var(--dg-surface);
    border-radius: var(--dg-radius-lg);
    padding: var(--dg-space-8);
    box-shadow: var(--dg-shadow-md);
    border: var(--dg-border-width-thin) solid var(--dg-border);
}

.dg-panel {
    background-color: var(--dg-surface-elevated);
    padding: var(--dg-space-5);
    border-radius: var(--dg-radius-md);
    margin-bottom: var(--dg-space-5);
    border: var(--dg-border-width-thin) solid var(--dg-border);
}

.dg-two-column-layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--dg-space-5);
    min-height: 300px;
}

@media (max-width: 768px) {
    .dg-two-column-layout {
        grid-template-columns: 1fr;
    }
}

.dg-content-section {
    background-color: var(--dg-surface-elevated);
    padding: var(--dg-space-5);
    border-radius: var(--dg-radius-md);
    border: var(--dg-border-width-thin) solid var(--dg-border);
    overflow: hidden;
    min-width: 0;
}

h1 {
    color: var(--dg-text-primary);
    text-align: center;
    margin-bottom: var(--dg-space-8);
    font-size: var(--dg-text-xl);
    font-weight: var(--dg-font-weight-semibold);
}

h3 {
    margin-top: 0;
    color: var(--dg-text-primary);
    font-size: var(--dg-text-lg);
    font-weight: var(--dg-font-weight-medium);
    margin-bottom: var(--dg-space-4);
}

.dg-text-center {
    text-align: center;
}

.dg-input-group {
    margin-bottom: var(--dg-space-4);
}

label {
    display: block;
    margin-bottom: var(--dg-space-2);
    font-weight: var(--dg-font-weight-medium);
    color: var(--dg-text-secondary);
    font-size: var(--dg-text-sm);
}

input[type="number"], input[type="text"], select {
    width: 100%;
    padding: var(--dg-space-3);
    border: var(--dg-border-width-thin) solid var(--dg-border);
    border-radius: var(--dg-radius-md);
    font-size: var(--dg-text-base);
    background-color: var(--dg-surface);
    color: var(--dg-text-primary);
    transition: border-color var(--dg-transition-normal), box-shadow var(--dg-transition-normal);
    box-sizing: border-box;
}

input:focus, select:focus {
    outline: none;
    border-color: var(--dg-primary);
    box-shadow: 0 0 0 3px rgba(19, 239, 147, 0.1);
}

small {
    color: var(--dg-text-muted);
    font-size: var(--dg-text-sm);
    display: block;
    margin-top: var(--dg-space-2);
}

.btn {
    padding: var(--dg-space-3) var(--dg-space-6);
    border: none;
    border-radius: var(--dg-radius-md);
    font-size: var(--dg-text-base);
    font-weight: var(--dg-font-weight-medium);
    cursor: pointer;
    transition: all var(--dg-transition-normal);
    font-family: var(--dg-font-family-body);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    box-sizing: border-box;
}

.btn:focus {
    outline: none;
}

.btn:focus-visible {
    box-shadow: 0 0 0 var(--dg-border-width-thin) var(--dg-primary);
}

.btn--primary {
    background-color: var(--dg-primary);
    color: var(--dg-text-inverse);
    border: var(--dg-border-width-thin) solid transparent;
}

.btn--primary:hover:not(:disabled) {
    background-color: var(--dg-primary-hover);
    color: var(--dg-white);
}

.btn--secondary {
    background-color: var(--dg-surface-elevated);
    border: var(--dg-border-width-thin) solid var(--dg-border);
    color: var(--dg-text-primary);
}

.btn--secondary:hover:not(:disabled) {
    background-color: var(--dg-surface);
    border-color: var(--dg-border-strong);
    box-shadow: var(--dg-shadow-sm);
}

.btn--danger {
    background-color: var(--dg-danger);
    color: var(--dg-white);
    border: var(--dg-border-width-thin) solid transparent;
}

.btn--danger:hover:not(:disabled) {
    background-color: var(--dg-danger-hover);
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
}

.dg-controls {
    display: flex;
    gap: var(--dg-space-3);
    justify-content: center;
    margin: var(--dg-space-5) 0;
    flex-wrap: wrap;
}

@media (max-width: 640px) {
    .dg-controls {
        flex-direction: column;
        align-items: stretch;
    }
    .dg-controls .btn {
        width: 100%;
    }
}

.dg-status {
    padding: var(--dg-space-3);
    border-radius: var(--dg-radius-md);
    margin-bottom: var(--dg-space-5);
    font-weight: var(--dg-font-weight-medium);
    font-size: var(--dg-text-base);
    text-align: center;
    border: var(--dg-border-width-thin) solid transparent;
}

.dg-status--disconnected {
    background-color: rgba(240, 68, 56, 0.1);
    color: var(--dg-danger);
    border-color: var(--dg-danger);
}

.dg-status--connecting {
    background-color: rgba(254, 200, 75, 0.1);
    color: var(--dg-warning);
    border-color: var(--dg-warning);
}

.dg-status--connected {
    background-color: rgba(18, 183, 106, 0.1);
    color: var(--dg-success);
    border-color: var(--dg-success);
}

.dg-event-log {
    background-color: var(--dg-void);
    color: var(--dg-primary);
    padding: var(--dg-space-4);
    border-radius: var(--dg-radius-sm);
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: var(--dg-text-sm);
    height: 250px;
    overflow-y: auto;
    overflow-x: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-width: 100%;
    box-sizing: border-box;
    border: var(--dg-border-width-thin) solid var(--dg-border);
}

.dg-transcript-display {
    background-color: var(--dg-surface);
    border: var(--dg-border-width-thin) solid var(--dg-border);
    padding: var(--dg-space-4);
    border-radius: var(--dg-radius-sm);
    min-height: 100px;
    font-size: var(--dg-text-base);
    line-height: 1.5;
    color: var(--dg-text-primary);
}

.dg-info-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--dg-space-3);
    margin-bottom: var(--dg-space-4);
}

@media (max-width: 640px) {
    .dg-info-grid {
        grid-template-columns: 1fr;
    }
}

.dg-info-item {
    background-color: var(--dg-surface);
    padding: var(--dg-space-3);
    border-radius: var(--dg-radius-sm);
    border: var(--dg-border-width-thin) solid var(--dg-border);
    font-size: var(--dg-text-sm);
}

.dg-info-label {
    font-weight: var(--dg-font-weight-medium);
    color: var(--dg-text-muted);
    display: block;
    font-size: var(--dg-text-sm);
}

.dg-info-value {
    color: var(--dg-text-primary);
    margin-top: var(--dg-space-2);
    font-weight: var(--dg-font-weight-medium);
}

.dg-sticky-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background-color: var(--dg-surface);
    border-bottom: var(--dg-border-width-thin) solid var(--dg-border);
    box-shadow: var(--dg-shadow-md);
    backdrop-filter: blur(8px);
}

.dg-sticky-nav__container {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--dg-space-4) var(--dg-space-5);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.dg-sticky-nav__logo {
    display: flex;
    align-items: center;
    gap: var(--dg-space-3);
}

.dg-sticky-nav__logo-text {
    font-size: var(--dg-text-lg);
    font-weight: var(--dg-font-weight-semibold);
    color: var(--dg-text-primary);
}

.dg-sticky-nav__menu {
    display: flex;
    align-items: center;
    gap: var(--dg-space-4);
}

.dg-github-btn {
    display: inline-flex;
    align-items: center;
    gap: var(--dg-space-2);
    padding: var(--dg-space-2) var(--dg-space-4);
    background-color: var(--dg-surface-elevated);
    border: var(--dg-border-width-thin) solid var(--dg-border);
    border-radius: var(--dg-radius-md);
    color: var(--dg-text-primary);
    text-decoration: none;
    font-size: var(--dg-text-sm);
    font-weight: var(--dg-font-weight-medium);
    transition: all var(--dg-transition-normal);
}

.dg-github-btn:hover {
    background-color: var(--dg-surface);
    border-color: var(--dg-border-strong);
    box-shadow: var(--dg-shadow-sm);
    color: var(--dg-text-primary);
}

.dg-status-btn {
    display: inline-flex;
    align-items: center;
    gap: var(--dg-space-2);
    padding: var(--dg-space-2) var(--dg-space-4);
    border: var(--dg-border-width-thin) solid;
    border-radius: var(--dg-radius-md);
    font-size: var(--dg-text-sm);
    font-weight: var(--dg-font-weight-medium);
    transition: all var(--dg-transition-normal);
}

.dg-status-btn--disconnected {
    background-color: rgba(240, 68, 56, 0.1);
    color: var(--dg-danger);
    border-color: var(--dg-danger);
}

.dg-status-btn--connecting {
    background-color: rgba(254, 200, 75, 0.1);
    color: var(--dg-warning);
    border-color: var(--dg-warning);
}

.dg-status-btn--connected {
    background-color: rgba(18, 183, 106, 0.1);
    color: var(--dg-success);
    border-color: var(--dg-success);
}

@media (max-width: 768px) {
    .dg-sticky-nav__container {
        padding: var(--dg-space-3) var(--dg-space-4);
    }
    .dg-sticky-nav__logo-text {
        font-size: var(--dg-text-base);
    }
    .dg-github-btn {
        padding: var(--dg-space-2) var(--dg-space-3);
        font-size: var(--dg-text-sm);
    }
    .dg-status-btn {
        padding: var(--dg-space-2) var(--dg-space-3);
        font-size: var(--dg-text-sm);
    }
    .dg-github-text {
        display: none;
    }
}
    </style>
  </head>
  <body>
    <!-- Sticky Navigation -->
    <nav class="dg-sticky-nav">
        <div class="dg-sticky-nav__container">
            <div class="dg-sticky-nav__logo">
                <span class="dg-sticky-nav__logo-text">
                    Deepgram Flux Streaming Demo
                </span>
            </div>
            <div class="dg-sticky-nav__menu">
                <span class="dg-status-btn dg-status-btn--disconnected" id="connectionStatus">
                    Disconnected
                </span>
                <a href="http://developers.deepgram.com/docs/stt/getting-started" class="dg-github-btn" target="_blank" rel="noopener noreferrer">
                    <span class="dg-github-text">Documentation</span>
                </a>
                <a href="https://github.com/deepgram-devs/deepgram-demos-flux-streaming" class="dg-github-btn" target="_blank" rel="noopener noreferrer">
                    <span class="dg-github-text">View on GitHub</span>
                </a>
            </div>
        </div>
    </nav>

    <!-- Main Content with body padding for sticky nav -->
    <div class="dg-body-with-sticky-nav">
        <div class="dg-container">
            <h1>ðŸŽ¤ Deepgram Flux Streaming Demo</h1>
            <p class="dg-prose--small dg-text-center">Use the Deepgram Flux Streaming API to transcribe speech in real-time.</p>

        <div class="dg-panel">
            <h3>FLUX Configuration</h3>
            <div class="dg-input-group">
                <label for="eagerEotThreshold">Eager End-of-Turn Threshold (0.3-0.9, optional):</label>
                <input type="number" id="eagerEotThreshold" min="0.3" max="0.9" step="0.1"
                       placeholder="Leave empty to disable eager end-of-turn detection">
                <small>
                    Enable early turn detection for lower latency voice agents
                </small>
            </div>
            <div class="dg-input-group">
                <label for="eotThreshold">End-of-Turn Threshold (0.5-0.9):</label>
                <input type="number" id="eotThreshold" min="0.5" max="0.9" step="0.1" value="0.7">
                <small>
                    Confidence level required to detect end of speech turn
                </small>
            </div>
        </div>

            <div class="dg-controls">
                <button id="connectBtn" class="btn btn--primary">Connect to FLUX</button>
                <button id="startMicBtn" class="btn btn--secondary" disabled> Start Microphone</button>
                <button id="stopStreamBtn" class="btn btn--danger" disabled>Stop</button>
            </div>

        <div class="dg-two-column-layout">
            <div class="dg-content-section">
                <h3>FLUX Events</h3>
                <div id="eventLog" class="dg-event-log"></div>
            </div>
            <div class="dg-content-section">
                <h3>Current Turn</h3>
                <div class="dg-info-grid">
                    <div class="dg-info-item">
                        <span class="dg-info-label">Turn Index</span>
                        <div class="dg-info-value" id="turnIndex">-</div>
                    </div>
                    <div class="dg-info-item">
                        <span class="dg-info-label">Current Event</span>
                        <div class="dg-info-value" id="currentEvent">-</div>
                    </div>
                    <div class="dg-info-item">
                        <span class="dg-info-label">End-of-Turn Confidence</span>
                        <div class="dg-info-value" id="eotConfidence">-</div>
                    </div>
                    <div class="dg-info-item">
                        <span class="dg-info-label">Audio Window</span>
                        <div class="dg-info-value" id="audioWindow">-</div>
                    </div>
                </div>
                <div class="dg-transcript-display" id="currentTranscript">
                    Transcript will appear here...
                </div>
            </div>
        </div>
    </div>

    <script>
        class FluxDemo {
            constructor() {
                this.ws = null;
                this.audioContext = null;
                this.mediaStream = null;
                this.processor = null;
                this.isUsingMicrophone = false;

                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                this.elements = {
                    eagerEotThreshold: document.getElementById('eagerEotThreshold'),
                    eotThreshold: document.getElementById('eotThreshold'),
                    connectionStatus: document.getElementById('connectionStatus'),
                    connectBtn: document.getElementById('connectBtn'),
                    startMicBtn: document.getElementById('startMicBtn'),
                    stopStreamBtn: document.getElementById('stopStreamBtn'),
                    eventLog: document.getElementById('eventLog'),
                    currentTranscript: document.getElementById('currentTranscript'),
                    turnIndex: document.getElementById('turnIndex'),
                    currentEvent: document.getElementById('currentEvent'),
                    eotConfidence: document.getElementById('eotConfidence'),
                    audioWindow: document.getElementById('audioWindow')
                };
            }

            setupEventListeners() {
                this.elements.connectBtn.onclick = () => this.toggleConnection();
                this.elements.startMicBtn.onclick = () => this.startMicrophone();
                this.elements.stopStreamBtn.onclick = () => this.stopAll();
            }

            toggleConnection() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.disconnect();
                } else {
                    this.connect();
                }
            }

            connect() {
                this.updateStatus('connecting', 'Connecting...');
                this.elements.connectBtn.disabled = true;

                // Build WebSocket URL with parameters for our local proxy
                // Auto-detect if we're running under /flux-streaming path
                const BASE_PATH = (location.pathname === '/flux-streaming' || location.pathname.startsWith('/flux-streaming/')) ? '/flux-streaming' : '';
                const params = new URLSearchParams({
                    model: 'flux-general-en',
                    sample_rate: '16000',
                    encoding: 'linear16',
                    eot_threshold: this.elements.eotThreshold.value || '0.7'
                });

                // Add eager eot threshold if specified
                const eagerEotThreshold = this.elements.eagerEotThreshold.value;
                if (eagerEotThreshold) {
                    if (eagerEotThreshold > (this.elements.eotThreshold.value || 0.7)) {
                        this.log('âŒ Eager End-of-Turn Threshold must be below End-of-Turn Threshold');
                        this.updateStatus('disconnected', 'Disconnected');
                        this.elements.connectBtn.disabled = false;
                        return;
                    }
                    params.append('eager_eot_threshold', eagerEotThreshold);
                }

                // Connect to our local WebSocket proxy server (same host, configured base path)
                const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
                const wsUrl = `${wsProtocol}://${location.host}${BASE_PATH}?${params.toString()}`;
                this.log(`ðŸ”— Connecting to: ${wsUrl}`);
                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    this.log('âœ… Connected to FLUX API via proxy server');
                    this.updateStatus('connected', 'Connected to FLUX API');
                    this.elements.connectBtn.textContent = 'Disconnect';
                    this.elements.connectBtn.disabled = false;
                    this.elements.startMicBtn.disabled = false;
                };

                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.log(`ðŸ“¨ Raw WebSocket message: ${event.data.substring(0, 200)}${event.data.length > 200 ? '...' : ''}`);
                        this.handleFluxMessage(data);
                    } catch (error) {
                        this.log(`âŒ Error parsing message: ${error.message}`);
                        this.log(`ðŸ“¨ Raw message: ${event.data.substring(0, 100)}`);
                    }
                };

                this.ws.onclose = (event) => {
                    this.log(`WebSocket closed: ${event.code} - ${event.reason}`);
                    this.updateStatus('disconnected', 'Disconnected');
                    this.elements.connectBtn.textContent = 'Connect to FLUX';
                    this.elements.connectBtn.disabled = false;
                    this.elements.startMicBtn.disabled = true;
                    this.elements.stopStreamBtn.disabled = true;
                    this.stopAll();
                };

                this.ws.onerror = (error) => {
                    this.log(`WebSocket error: ${error.message || 'Unknown error'}`);
                    this.updateStatus('disconnected', 'Connection error');
                    this.elements.connectBtn.disabled = false;
                };
            }

            disconnect() {
                if (this.ws) {
                    this.stopAll();
                    this.ws.close();
                    this.ws = null;
                }
            }


            async startMicrophone() {
                if (this.isUsingMicrophone) return;

                try {
                    this.log('ðŸŽ¤ Starting FLUX transcription with Linear16 PCM...');
                    this.log('âš ï¸  FLUX API requires raw PCM data, not compressed audio formats');

                    // Request microphone access with specific constraints for FLUX
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: false,  // Disable processing for cleaner PCM
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });

                    this.log('âœ… Microphone access granted');
                    this.isUsingMicrophone = true;
                    this.elements.startMicBtn.disabled = true;
                    this.elements.stopStreamBtn.disabled = false;
                    this.mediaStream = stream;

                    // Create audio context at exactly 16kHz for FLUX
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });

                    this.log(`ðŸ”§ Audio context sample rate: ${this.audioContext.sampleRate}Hz`);

                    const source = this.audioContext.createMediaStreamSource(stream);

                    // Use 1024 samples (64ms at 16kHz) - must be power of 2 for createScriptProcessor
                    const bufferSize = 1024;
                    this.processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);

                    let chunkCount = 0;
                    let lastLogTime = 0;

                    this.processor.onaudioprocess = (event) => {
                        chunkCount++;
                        const now = Date.now();

                        // Log every 2 seconds to avoid spam
                        if (now - lastLogTime > 2000) {
                            this.log(`ðŸ”Š Audio processing: ${chunkCount} chunks processed, WebSocket: ${this.ws ? this.ws.readyState : 'null'}`);
                            lastLogTime = now;
                        }

                        if (this.isUsingMicrophone && this.ws && this.ws.readyState === WebSocket.OPEN) {
                            const inputData = event.inputBuffer.getChannelData(0);

                            // Check if we have actual audio signal
                            let hasSignal = false;
                            let maxAmplitude = 0;
                            for (let i = 0; i < inputData.length; i++) {
                                const abs = Math.abs(inputData[i]);
                                if (abs > maxAmplitude) maxAmplitude = abs;
                                if (abs > 0.001) hasSignal = true; // Threshold for detecting audio
                            }

                            // Log audio level periodically
                            if (chunkCount % 32 === 0) { // Every ~2 seconds at 64ms chunks
                                this.log(`ðŸŽµ Audio level: max=${(maxAmplitude * 100).toFixed(1)}%, signal=${hasSignal ? 'YES' : 'SILENT'}`);
                            }

                            // Convert Float32 to Int16 (Linear16 PCM format for FLUX)
                            const int16Array = new Int16Array(inputData.length);
                            for (let i = 0; i < inputData.length; i++) {
                                // Clamp and convert to 16-bit signed integer
                                const clampedValue = Math.max(-1, Math.min(1, inputData[i]));
                                int16Array[i] = Math.round(clampedValue * 32767);
                            }

                            // Log first few successful sends
                            if (chunkCount <= 5) {
                                this.log(`ðŸ“¤ Sending chunk ${chunkCount}: ${int16Array.length} samples, ${int16Array.buffer.byteLength} bytes`);
                            }

                            // Send Linear16 PCM data to FLUX API
                            this.ws.send(int16Array.buffer);
                        } else {
                            if (chunkCount <= 3) {
                                this.log(`âŒ Cannot send audio: mic=${this.isUsingMicrophone}, ws=${this.ws ? 'exists' : 'null'}, readyState=${this.ws ? this.ws.readyState : 'n/a'}`);
                            }
                        }
                    };

                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);

                    this.log('ðŸŽ¤ Linear16 PCM streaming started - speak now!');
                    this.log(`ðŸ“Š Sending ${bufferSize} samples (${(bufferSize/16000*1000).toFixed(0)}ms) per chunk`);

                } catch (error) {
                    this.log(`âŒ Microphone error: ${error.message}`);
                    this.isUsingMicrophone = false;
                    this.elements.startMicBtn.disabled = false;
                    this.elements.stopStreamBtn.disabled = true;
                }
            }

            stopAll() {
                // Stop microphone
                if (this.isUsingMicrophone) {
                    this.log('ðŸŽ¤ Stopping microphone');
                    this.isUsingMicrophone = false;

                    if (this.processor) {
                        this.processor.disconnect();
                        this.processor = null;
                    }

                    if (this.audioContext && this.audioContext.state !== 'closed') {
                        this.audioContext.close();
                        this.audioContext = null;
                    }

                    if (this.mediaStream) {
                        this.mediaStream.getTracks().forEach(track => track.stop());
                        this.mediaStream = null;
                    }
                }

                // Reset button states
                this.elements.startMicBtn.disabled = false;
                this.elements.stopStreamBtn.disabled = true;
            }

            // Backward compatibility
            stopAudioStream() {
                this.stopAll();
            }

            handleFluxMessage(data) {
                this.log(`Received: ${JSON.stringify(data, null, 2)}`);

                // Handle TurnInfo messages (FLUX API responses)
                if (data.type === 'TurnInfo') {
                    this.updateTurnInfo(data);

                    switch(data.event) {
                        case 'StartOfTurn':
                            this.log('ðŸŸ¢ User started speaking');
                            break;
                        case 'EagerEndOfTurn':
                            this.log('ðŸŸ¡ Eager end of turn - medium confidence turn end');
                            break;
                        case 'TurnResumed':
                            this.log('ðŸ”„ Turn resumed after eager end of turn');
                            break;
                        case 'EndOfTurn':
                            this.log('ðŸ”´ End of turn - high confidence');
                            break;
                        case 'Update':
                            this.log('ðŸ“ Transcript update');
                            break;
                    }
        } else {
                    // Log other message types for debugging
                    this.log(`ðŸ“¨ Message type: ${data.type || 'unknown'}`);
                }
            }

            updateTurnInfo(data) {
                this.elements.turnIndex.textContent = data.turn_index || '-';
                this.elements.currentEvent.textContent = data.event || '-';
                this.elements.eotConfidence.textContent =
                    data.end_of_turn_confidence ? data.end_of_turn_confidence.toFixed(2) : '-';
                this.elements.audioWindow.textContent =
                    data.audio_window_start !== undefined && data.audio_window_end !== undefined
                        ? `${data.audio_window_start.toFixed(1)}s - ${data.audio_window_end.toFixed(1)}s`
                        : '-';
                this.elements.currentTranscript.textContent = data.transcript || this.elements.currentTranscript.textContent;
            }

            updateStatus(type, message) {
                this.elements.connectionStatus.className = `dg-status-btn dg-status-btn--${type}`;
                this.elements.connectionStatus.textContent = message;
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}\n`;
                this.elements.eventLog.textContent += logMessage;
                this.elements.eventLog.scrollTop = this.elements.eventLog.scrollHeight;
            }
        }

        // Initialize the demo when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new FluxDemo();
        });
    </script>
        </div>
    </div>
  </body>
</html>